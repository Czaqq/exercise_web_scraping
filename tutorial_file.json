{
    "https://generativeartistry.com/tutorials/hours-of-dark/": {
        "text": [
            "This post is from the talented brunoimbrizi, if you're interested in posting, you can open up a proposal, just like he did!",
            "In this tutorial, we are going to recreate the look of a print by Accept & Proceed called Hours of Dark 2011. All the strokes in the grid represent a day, their width proportional to the hours of darkness and their orientation defined by the angle of the sunset.",
            "Here is our initial setup with a single <canvas> element, using window.devicePixelRatio to scale it on retina screens.",
            "We need a few variables to describe the grid. First, the number of strokes which is the same as the number of days in a non-leap year. Then the number of columns and rows, just enough to pack 365 cells in the grid. In this case 23×16 = 368, so the last 3 cells will be blank.",
            "We also need variables to define the dimensions of the grid, which has a landscape aspect. And from that we can calculate the dimensions of each cell and the top and left margins.",
            "Now we have enough to start drawing the strokes. We are going to loop over days column by column, so first, all the rows in the first column, then all the rows in the second column and so on.",
            "x and y depend on the margins and on the cell dimensions. The width and height of each stroke (w, h) are arbitrary values which look right for the size of our canvas on the page. The rectangles are drawn from the centre, so this will be their anchor point when we rotate them later.",
            "At this point, the grid is a bit offset to the left and to the top, and this is because x and y are the top-left of each cell. So we need one more call to translate to place the origin at the centre of the cell. These separate calls will come in handy later.",
            "Now we need to calculate the rotation. In the original calendar, the authors used data from the angle of the sunset (known as the Azimuth) to determine the orientation of the lines. Luckily for us, we can get pretty close with a sine curve, thanks to the smooth wobble of our planet.",
            "The trick here is to use two angles.",
            "The first one phi determines the range of rotation in a year, which is between 0 and Π.",
            "The second one theta modulates the first one with a sine curve, so instead of rotating a full 180°, it eases in and out of the first half of that angle and then eases back into 0°.",
            "To match the look, we need to nudge the inital angle. We also need to adjust the rotation range so it’s a little bit less than 90°.",
            "The thickness of the strokes is proportional to the hours of darkness in each day. Again, we can get away with a good approximation using a cosine curve.",
            "The last step is to apply a clipping mask so each stroke is only drawn inside its cell. This is where our separate calls to translate come in handy, so we need to insert the next chunk of code in between those calls.",
            "And there we have it! Simple and elegant. A beautiful piece of data visualisation from Accept & Proceed which we managed to recreate with some sine and cosine curves."
        ],
        "code": "1 2 3 4 5 6 7 8 9 var canvas = document . querySelector ( 'canvas' ); var context = canvas . getContext ( '2d' ); var size = window . innerWidth ; var dpr = window . devicePixelRatio ; canvas . width = size * dpr ; canvas . height = size * dpr ; context . scale ( dpr , dpr ); 10 11 12 13 var cols = 23 ; var rows = 16 ; var days = 365 ; 14 15 16 17 18 19 20 var gridw = size * 0.9 ; var gridh = size * 0.7 ; var cellw = gridw / cols; var cellh = gridh / rows; var margx = ( size - gridw ) * 0.5 ; var margy = ( size - gridh ) * 0.5 ; 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 for ( let i = 0 ; i < days ; i ++ ) { var col = Math . floor ( i / rows); var row = i % rows ; var x = margx + col * cellw ; var y = margy + row * cellh ; var w = 2 ; var h = 30 ; context . save (); context . translate ( x , y ); context . beginPath (); context . rect ( w * - 0.5 , h * - 0.5 , w , h ); context . fill (); context . restore (); } 32 33 context . translate ( cellw * 0.5 , cellh * 0.5 ); 34 35 36 37 38 39 var phi = ( i / days) * Math.PI; var theta = Math . sin ( phi ) * Math . PI * 0.5 ; context . rotate ( theta ); 35 36 var theta = Math . sin ( phi ) * Math . PI * 0.45 + 0.85 ; 39 40 41 42 43 var scale = Math . abs ( Math . cos ( phi )) * 2 + 1 ; context . scale ( scale , 1 ); 32 33 34 35 36 37 context . beginPath (); context . rect ( 0 , 0 , cellw , cellh ); context . clip ();"
    },
    "https://generativeartistry.com/tutorials/piet-mondrian/": {
        "text": [
            "Replicating Piet Mondrian’s art with code is no easy task, in fact honestly I’d say there’s no real way of pinning down his creations entirely with code, they were hand made. That said, we can try to replicate something within the realm of what would have been one of Piet’s works… so that’s what we will do in this tutorial… and yes, we will add the color as well.",
            "As usual, here is our initial setup. Using window.devicePixelRatio to scale the canvas on retina screens, and setting our canvas size, with only a html <canvas> on the page.",
            "Now, the approach I’d like to take isn’t perfect, but what I’d like to do is start with a big square (the canvas) and then start to divide it up… we will pick a line, either horizontally or vertically and break any squares in that area… after that, we’ll add some random to the splitting, so not all squares are split, which should give us something around the famous Mondrian look, albeit probably a little more mathematically rigid.",
            "We’ll create an array of squares.",
            "And, as I like to do, we’ll create our “draw” function and call it, so we can see what we’re making.",
            "This is looping through all of our squares (just one at the moment, and drawing it on the canvas).",
            "Now, we can create a function to find which squares should be split… and then the function to split the square in the direction we’ve given.",
            "You can see at the bottom that I’m also calling the split the squares on the x and y, both in the middle. If these work, we’ll know we can do a lot more splitting. But for now, these will be great for testing.",
            "First, the splitSquaresWith function.",
            "There’s a bit going on here, including some cheeky little tricks.",
            "Of course, our single square has disappeared because we need to fill out the splitOn functions, these are going to look pretty similar.",
            "And…",
            "These two functions are creating two squares, where the previous single square was, and then adding them back into our squares array. You can see by splitting in the two centers, we’ve made a window.",
            "Instead of our two practice splits, we’ll create a step variable, and split on that step over and over.",
            "And then the loop.",
            "Whew, that was a lot of set up… we can get into the random now. Rather than splitting each and every square when we hit it, we’ll only split them half the time.",
            "Ooh, looking good. And on the y axis too!",
            "And there we have it, the shapes and structure we want! As always, with these tutorials you can hit the small arrow sitting between the editor and the demo and the code will rerun, if you press it a few times now, you’ll see our Mondrian structure take a few different shapes.",
            "Let’s add some color in. First the variables, using those beautiful red, blue and yellow colors.",
            "We’ll pick three random squares, and give each of them a color. You might see only one or two colors, and that is because the same square was randomly selected twice.",
            "And of course, making sure the draw function colors them in.",
            "Colors, beautiful! Again, if you don’t see any, it should be a matter of hitting the arrow on the side a few times.",
            "You can see now as well, how simple it is to add or remove complexity based on the grid.",
            "And there we have it, a Mondrian. Please, hit the link below to have a play on CodePen, play with the colors, how you apply them, play with the split percentages. It’s all good fun!"
        ],
        "code": " 1  2  3  4  5  6  7  8  9 10 var canvas = document . querySelector ( 'canvas' ); var context = canvas . getContext ( '2d' ); var size = window . innerWidth ; var dpr = window . devicePixelRatio ; canvas . width = size * dpr ; canvas . height = size * dpr ; context . scale ( dpr , dpr ); context . lineWidth = 8 ; 11 12 13 14 15 16 17 var squares = [{ x : 0 , y : 0 , width : size , height : size }]; 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function draw () { for ( var i = 0 ; i < squares . length ; i ++ ) { context . beginPath (); context . rect ( squares [ i ]. x , squares [ i ]. y , squares [ i ]. width , squares [ i ]. height ); context . stroke (); } } draw () 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 function splitSquaresWith ( coordinates ) { // Loops through the squares, and find if  // one should be split  } function splitOnX ( square , splitAt ) { // Create two new squares, based on // splitting the given one at the // x coordinate given  } function splitOnY ( square , splitAt ) { // Create two new squares, based on // splitting the given one at the // y coordinate given  } splitSquaresWith ({ x : 160 }) splitSquaresWith ({ y : 160 }) 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const { x , y } = coordinates ; for ( var i = squares . length - 1 ; i >= 0 ; i -- ) { const square = squares [ i ]; if ( x && x > square . x && x < square . x + square . width ) { squares . splice ( i , 1 ); splitOnX ( square , x ); } if ( y && y > square . y && y < square . y + square . height ) { squares . splice ( i , 1 ); splitOnY ( square , y ); } } 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 var squareA = { x : square . x , y : square . y , width : square . width - ( square . width - splitAt + square . x ), height : square . height }; var squareB = { x : splitAt , y : square . y , width : square . width - splitAt + square . x , height : square . height }; squares . push ( squareA ); squares . push ( squareB ); 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 var squareA = { x : square . x , y : square . y , width : square . width , height : square . height - ( square . height - splitAt + square . y ) }; var squareB = { x : square . x , y : splitAt , width : square . width , height : square . height - splitAt + square . y }; squares . push ( squareA ); squares . push ( squareB ); 10 11 var step = size / 6; 75 76 77 78 79 for ( var i = 0 ; i < size ; i += step ) { splitSquaresWith ({ y : i }); splitSquaresWith ({ x : i }); } 26 27 28 29 30 if ( Math . random () > 0.5 ) { squares . splice ( i , 1 ); splitOnX ( square , x ); } 33 34 35 36 37 if ( Math . random () > 0.5 ) { squares . splice ( i , 1 ); splitOnY ( square , y ); } 11 12 13 var white = '#F2F5F1' ; var colors = [ '#D40920' , '#1356A2' , '#F7D842' ] 87 88 89 90 for ( var i = 0 ; i < colors . length ; i ++ ) { squares [ Math . floor ( Math . random () * squares . length )]. color = colors [ i ]; } 97 98 99 100 101 102 103 if ( squares [ i ]. color ) { context . fillStyle = squares [ i ]. color ; } else { context . fillStyle = white } context . fill () 10 11 var step = size / 20; 10 11 var step = size / 4; 10 11 var step = size / 7;"
    },
    "https://generativeartistry.com/tutorials/hypnotic-squares/": {
        "text": [
            "William Kolomyjec’s work is again reminiscent of some of the old school generative works, focusing on simple shapes, tiling and recursion.",
            "Today we’re going to replicate a piece of his called Hypnotic Squares.",
            "The only HTML we have on the page is a <canvas> element at 320×320 pixels.",
            "As usual, here is our initial setup. Using window.devicePixelRatio to scale the canvas on retina screens, and setting our canvas size.",
            "Now, to create this piece we’re going to need to set a few variables, and then we will create our draw function. The goal will be to create a function that uses recursion to draw squares inside itself, until they reach a certain minimum size.",
            "If you don’t know much about recursion, that’s totally ok! I will explain it as we go through.",
            "The steps in the draw function, is how many times our square will recurse inwards. It’s a fixed variable now, but we will be able to make it a little bit more random later.",
            "The finalSize is the smallest square we want to draw, when our squares start to get this small, we’ll stop drawing.",
            "The startSteps will help us calculate a smaller and smaller square as we recurse.",
            "Let’s make our draw function draw. We’ll start with just a plain square.",
            "Now we have a single square, its time for some recursion. This means that the draw function will be calling itself over and over, until we reach a certain condition, this condition is pretty important, otherwise the loop will never end. We will use steps and count down.",
            "Woohoo, recursion! So let me explain whats going on above.",
            "So you can see now if we change the startSteps variable, to a few differnt variations, we’ll have different degrees of recursion.",
            "or",
            "We can see that randomizing this value will give us different outputs, but lets add a little more to it first. You can see the two variables xMovement and yMovement… we want to use these variables to “tilt” the squares in a certain direction.",
            "First, I’ll update the draw call, to represent this, with xMovement and yMovement both being 1. We will want this to tilt the square to the bottom right.",
            "And here’s what we will do, to calculate this.",
            "This looks a little complex… we’re calculating how big each step is going to be (difference between the bigger and smaller square sizes) and then dividing it by how many steps are left. The 2 is to make sure that the new square never quite touches the line of the previous one.",
            "Now, if we change around our draw function, you’ll be able to see how it moves around and renders in different ways.",
            "Ok, now that we have our draw function down, we’re going to do something we did in our very first tiled lines tutorial… and that is, tile!",
            "Firstly some variables, about how often we will tile our squares, and a little offset to center the square a little more… we will make the final size smaller, and calculate tileStep to be the width of our canvas minus the offsetdivided by how many squares we want (7). And then, a final array of all the possible directions we can go in -1, 0 & 1",
            "Yep, it looks broken, because we’re now going to use these variables to draw the tiles across our screen.",
            "Now we’re really set up to play. We can add a random amount of steps.",
            "And some random directions!",
            "And there we have it! Hypnotic Squares. This is a great example of some beautiful use of recursion, as well as the kind of art piece that can easily be expanded with some color, especially on a slightly larger canvas."
        ],
        "code": " 1  2  3  4  5  6  7  8  9 10 var canvas = document . querySelector ( 'canvas' ); var context = canvas . getContext ( '2d' ); var size = window . innerWidth ; var dpr = window . devicePixelRatio ; canvas . width = size * dpr ; canvas . height = size * dpr ; context . scale ( dpr , dpr ); context . lineWidth = 2 ; 11 12 13 14 15 16 17 18 19 20 var finalSize = 10 ; var startSize = size ; var startSteps = 5 ; function draw ( x , y , width , height , xMovement , yMovement , steps ) { // We will fill this in  } draw ( 0 , 0 , startSize , startSize , 0 , 0 , startSteps ); 16 17 18 19 context . beginPath (); context . rect ( x , y , width , height ); context . stroke (); 19 20 21 22 23 24 25 26 if ( steps >= 0 ) { var newSize = ( startSize ) * ( steps / startSteps) + finalSize; var newX = x + ( width - newSize ) / 2 var newY = y + ( height - newSize ) / 2 draw ( newX , newY , newSize , newSize , xMovement , yMovement , steps - 1 ); } 14 15 var startSteps = 8 ; 14 15 var startSteps = 4 ; 28 29 draw ( 0 , 0 , startSize , startSize , 1 , 1 , startSteps ); 28 29 30 newX = newX - (( x - newX ) / (steps + 2)) * xMovement newY = newY - (( y - newY ) / (steps + 2)) * yMovement 28 29 draw ( 0 , 0 , startSize , startSize , 1 , 0 , startSteps ); 30 31 draw ( 0 , 0 , startSize , startSize , 1 , - 1 , startSteps ); 30 31 draw ( 0 , 0 , startSize , startSize , 0 , - 1 , startSteps ); 30 31 draw ( 0 , 0 , startSize , startSize , - 1 , - 1 , startSteps ); 11 12 13 14 15 16 17 var finalSize = 3 ; var startSteps ; var offset = 2 ; var tileStep = ( size - offset * 2 ) / 7; var startSize = tileStep ; var directions = [ - 1 , 0 , 1 ]; 33 34 35 36 37 38 39 for ( var x = offset ; x < size - offset ; x += tileStep ) { for ( var y = offset ; y < size - offset ; y += tileStep ) { startSteps = 3 draw ( x , y , startSize , startSize , 1 , 1 , startSteps - 1 ); } } 35 36 startSteps = 2 + Math . ceil ( Math . random () * 3 ) 37 38 39 40 var xDirection = directions [ Math . floor ( Math . random () * directions . length )] var yDirection = directions [ Math . floor ( Math . random () * directions . length )] draw ( x , y , startSize , startSize , xDirection , yDirection , startSteps - 1 );"
    },
    "https://generativeartistry.com/tutorials/circle-packing/": {
        "text": [
            "Circle packing is such a fantastic effect, it looks infinitely complex, while also being mathematically beautiful. In this tutorial, we’re going to create a circle packing effect… Interestingly, this is a good example of an effect that isn’t particularly efficient to run, but at the same time, will still be very quick!",
            "As usual, we’re going to begin with a small, clean canvas. We will also set the size of the canvas and adjust it based on the user’s device pixel ratio, or pixel density. This ensures that the final result is crisp on all monitors.",
            "Now, I’m going to explain a little about our process, so we know which variables we will need. You’ll be able to see here that it’s not the most efficient, but it really gets the job done.",
            "Our steps will be:",
            "So, we have an array of circles, a totalCircles, a min & max circleSize and a createCircleAttempts. Let’s get this in code.",
            "Now we will spec out our process. We will make a createCircle and doesCircleHaveACollision function, and then fill it in with our goals… including calling the createAndDrawCircle function once for each of our totalCircles variable.",
            "This is the fun part, we can go through our functions and fill them in. If we tackle this in a step by step way, it will flow out really well.",
            "First, we’ll start with creating a circle object, we’ll give it an x, y and a radius",
            "Now, we’ll add it to our list of circles, and draw it… we didn’t really need to do this just yet, but being able to see what we’re coding render out really helps with the process.",
            "Awesome, and there we have it, tiny circles all over our screen. Next, we can look at growing them. We will do this 1 unit at a time, and when they collide, we’ll take one step back, and break out of the loop.",
            "Wow, what a mess we’ve made! Of course we know the reason for this. Currently our doesCircleHaveACollision function always returns false … we’ll need to fill that in.",
            "The way that we tell if circles have a collision, is a little bit of trigonometry. We’re going to loop through each of the circles that are drawn and compare them to the current circle being drawn. If their radii combined, is greater than the distance between each of their centers, then we know there’s a collision.",
            "To get the distance between the two center points, we will use pythagoras' theorem (whoa, that high school math coming in handy!)",
            "Almost there! But another small gotcha, when we’re creating our circles, there’s also a chance that they’re appearing inside others.",
            "We’re going to use a loop in the creation area now as well, its a little inefficient to randomly guess positions, but really at the end of the day, unless we were doing millions of circles, we won’t see any slow down.",
            "If the circle doesn’t find a safe place to draw, the attempt is abandoned.",
            "Wow, now we’ve got some beautiful circles, all packed in! There’s only one little step more to do, and that is to trigger a collision when they hit the wall as well as each other. We’ll break that into two if statements, one checking the top and bottom, and one checking the left and right.",
            "And there we have it! It’s not the prettiest code, but it’s a great example of how some complex things can be reasoned out, thought about, and stepped through with relative ease & a little math."
        ],
        "code": " 1  2  3  4  5  6  7  8  9 10 11 12 var canvas = document . querySelector ( 'canvas' ); var context = canvas . getContext ( '2d' ); var size = window . innerWidth ; var dpr = window . devicePixelRatio ; canvas . width = size * dpr ; canvas . height = size * dpr ; context . scale ( dpr , dpr ); context . lineWidth = 2 ; 12 13 14 15 16 17 18 var circles = []; var minRadius = 2 ; var maxRadius = 100 ; var totalCircles = 500 ; var createCircleAttempts = 500 ; 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 function createAndDrawCircle () { // Loop through from 0 to createCircleAttempts  // trying to create a circle.  // Once we have a circle created, grow it until  // it hits another, or reaches max size.  // Draw the circle  } function doesCircleHaveACollision ( circle ) { // Return true of false depending on whether the circle collides with another.  // but return false for now  return false ; } for ( var i = 0 ; i < totalCircles ; i ++ ) { createAndDrawCircle (); } 21 22 23 24 25 26 var newCircle = { x : Math . floor ( Math . random () * size ), y : Math . floor ( Math . random () * size ), radius : minRadius }; 29 30 31 32 33 circles . push ( newCircle ); context . beginPath (); context . arc ( newCircle . x , newCircle . y , newCircle . radius , 0 , 2 * Math . PI ); context . stroke (); 26 27 28 29 30 31 32 33 for ( var radiusSize = minRadius ; radiusSize < maxRadius ; radiusSize ++ ) { newCircle . radius = radiusSize ; if ( doesCircleHaveACollision ( newCircle )){ newCircle . radius -- ; break ; } } 40 41 42 43 44 45 46 47 48 49 50 51 for ( var i = 0 ; i < circles . length ; i ++ ) { var otherCircle = circles [ i ]; var a = circle . radius + otherCircle . radius ; var x = circle . x - otherCircle . x ; var y = circle . y - otherCircle . y ; if ( a >= Math . sqrt (( x * x ) + ( y * y ))) { return true ; } } 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var newCircle ; var circleSafeToDraw = false ; for ( var tries = 0 ; tries < createCircleAttempts ; tries ++ ) { newCircle = { x : Math . floor ( Math . random () * size ), y : Math . floor ( Math . random () * size ), radius : minRadius } if ( doesCircleHaveACollision ( newCircle )) { continue ; } else { circleSafeToDraw = true ; break ; } } if ( ! circleSafeToDraw ) { return ; } 66 67 68 69 70 71 72 73 74 75 76 if ( circle . x + circle . radius >= size || circle . x - circle . radius <= 0 ) { return true ; } if ( circle . y + circle . radius >= size || circle . y - circle . radius <= 0 ) { return true ; }"
    },
    "https://generativeartistry.com/tutorials/un-deux-trois/": {
        "text": [
            "Vera Molnár is a true inspiration to anyone interested in generative art. She is truly one of the very first people to be creating digital art, and one of the most compelling to follow. In this tutorial, we’re going to reproduce one of her works, Un Deux Trois.",
            "We’re going to use a somewhat standard setup here, getting our canvas and context which we will use to draw. We will also set the size of the canvas and adjust it based on the user’s device pixel ratio, or pixel density. This ensures that the final result is crisp on all monitors.",
            "Now, we’re going to set a few variables to our context. The first two, are to make the lines we will draw much thicker. The second two are variables we’re going to use to step through our canvas and draw our creation.",
            "Now, we’re going to create a draw function, which is going to accept an x & y coordinate, a width & height, and an array of positions. The positions will tell us where to draw specific lines. Here we have it.",
            "This is using context.translate to “move” the canvas to an x & y position, and then drawing lines in those coordinates based on the positions passed. So… let’s pass something in.",
            "So we can see now we’re drawing a small line in the middle (0.5) of each square. If we’re going to replicate Vera’s work, we’re going to want to get a little bit more complex than that, we’re going to use the aThirdOfHeight variable we defined previously, to draw 2 and 3 lines in our squares, when we are a third and two thirds down the screen.",
            "Awesome! Now we have increasing complexity as we go down the page, in the one, two, three pattern. All we need to do is add a little bit of random rotational magic and we’re going to have a beautiful piece. We’re going to add context.rotate(Math.random() * 5); to give us some random rotation, and alter our translates a little, to make sure they’re rotating from the center of each square.",
            "Beautiful. There we have it, Un Deux Trois. If you’re looking to explore other ideas, you could try getting more complex with more than 3 lines. Or perhaps play around with adding some color, remember, the fun of generative art is adding more variance and surprise, until you catch yourself off guard with something beautiful."
        ],
        "code": " 1  2  3  4  5  6  7  8  9 10 var canvas = document . querySelector ( 'canvas' ); var context = canvas . getContext ( '2d' ); var size = window . innerWidth ; var dpr = window . devicePixelRatio ; canvas . width = size * dpr ; canvas . height = size * dpr ; context . scale ( dpr , dpr ); 10 11 12 13 14 15 16 context . lineWidth = 4 ; context . lineCap = 'round' ; var step = 20 ; var aThirdOfHeight = size /3; 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function draw ( x , y , width , height , positions ) { context . save (); context . translate ( x , y ); for ( var i = 0 ; i <= positions . length ; i ++ ) { context . beginPath (); context . moveTo ( positions [ i ] * width , 0 ); context . lineTo ( positions [ i ] * width , height ); context . stroke (); } context . restore (); } 30 31 32 33 34 35 for ( var y = step ; y < size - step ; y += step ) { for ( var x = step ; x < size - step ; x += step ) { draw ( x , y , step , step , [ 0.5 ]); } } 30 31 32 33 34 35 36 37 if ( y < aThirdOfHeight ) { draw ( x , y , step , step , [ 0.5 ]); } else if ( y < aThirdOfHeight * 2 ) { draw ( x , y , step , step , [ 0.2 , 0.8 ]); } else { draw ( x , y , step , step , [ 0.1 , 0.5 , 0.9 ]); } 18 19 20 21 context . translate ( x + width /2, y + height/2); context . rotate ( Math . random () * 5 ); context . translate ( - width /2, -height/2);"
    },
    "https://generativeartistry.com/tutorials/triangular-mesh/": {
        "text": [
            "This post is from the talented maxwellito, if you're interested in posting, you can open up a proposal, just like he did!",
            "This triangular meshing effect is often shown off in libraries with SVG. Today we’re going to build it with canvas! It’s a great example of how a coordinate system and a little displacement can give clean beautiful effects.",
            "As usual we begin with a little setup code, a square canvas. We will also set the size of the canvas and adjust it based on the user’s device pixel ratio, or pixel density. This ensures that the final result is crisp on all monitors.",
            "Now let’s make a grid of dots. The standard way, regular lines and columns. For every dot coordinate we will draw it on the canvas, but also store the coordinate in an array for future use.",
            "Every coordinate will be represented by an object with 2 properties: x and y.",
            "The space between lines and columns is defined by the variable gap, we’ll draw these circles so we can see how our grid is placed out on the canvas.",
            "Now, we’re going to displace every other line on the x axis. We do this by alternating the variable called odd between true and false.",
            "We can see that the new pattern is shaping up to be a mesh of regular triangles.",
            "The next step will be using the dots to draw the triangles.",
            "To make our life easier let’s make a function that take the 3 coordinates of a triangle and draw them together.",
            "Now we’ll string up our drawTriangle function, and use the dots we generated earlier to draw all the triangles.",
            "This part might be a bit complex to understand. The script is going to go through all the lines and combining the two dots of the sibling line, forming triangles. The concatenation of two lines, let’s say line a and line b, and merge the dots into one array to make it look like a zig-zag: a1, b1, a2, b2, a3 etc.",
            "This will give us an array, containing each triangles specific coordinates. Looking something like [a1, b1, a2], [b1, a2, b2], [a2, b2, a3]…",
            "Now that we have a regular triangle mesh, we are one detail away from getting the magic to happen.",
            "Every dot is a gap away from the surrounding dots. So a dot can be moved in this area without overlapping with other dots. Let’s use a bit of Math.random() to get a random position in this area.",
            "And for a little extra generative fun, let’s add in some grays! Only 16 shades. No more.",
            "If you’re interested in exploring more detailed implementations of this effect, you can check out my library: triangulr"
        ],
        "code": " 1  2  3  4  5  6  7  8  9 10 var canvas = document . querySelector ( 'canvas' ); var context = canvas . getContext ( '2d' ); var size = window . innerWidth ; var dpr = window . devicePixelRatio ; canvas . width = size * dpr ; canvas . height = size * dpr ; context . scale ( dpr , dpr ); context . lineJoin = 'bevel' ; 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 var line , lines = [], gap = size / 7; for ( var y = gap / 2; y <= size; y+= gap) { line = []; for ( var x = gap / 2; x <= size; x+= gap) { line . push ({ x : x , y : y }); context . beginPath (); context . arc ( x , y , 1 , 0 , 2 * Math . PI , true ); context . fill (); } lines . push ( line ); } 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var line , dot , odd = false , lines = [], gap = size / 8; for ( var y = gap / 2; y <= size; y+= gap) { odd = ! odd ; line = []; for ( var x = gap / 4; x <= size; x+= gap) { dot = { x : x + ( odd ? gap /2 : 0), y: y}; line . push ( dot ); context . beginPath (); context . arc ( dot . x , dot . y , 1 , 0 , 2 * Math . PI , true ); context . fill (); } lines . push ( line ); } 29 30 31 32 33 34 35 36 37 38 function drawTriangle ( pointA , pointB , pointC ) { context . beginPath (); context . moveTo ( pointA . x , pointA . y ); context . lineTo ( pointB . x , pointB . y ); context . lineTo ( pointC . x , pointC . y ); context . lineTo ( pointA . x , pointA . y ); context . closePath (); context . stroke (); } 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 var dotLine ; odd = true ; for ( var y = 0 ; y < lines . length - 1 ; y ++ ) { odd = ! odd ; dotLine = []; for ( var i = 0 ; i < lines [ y ]. length ; i ++ ) { dotLine . push ( odd ? lines [ y ][ i ] : lines [ y + 1 ][ i ]); dotLine . push ( odd ? lines [ y + 1 ][ i ] : lines [ y ][ i ]); } for ( var i = 0 ; i < dotLine . length - 2 ; i ++ ) { drawTriangle ( dotLine [ i ], dotLine [ i + 1 ], dotLine [ i + 2 ]); } } 21 22 23 24 25 line . push ({ x : x + ( Math . random () * .8 - .4 ) * gap + ( odd ? gap /2 : 0), y : y + ( Math . random () * .8 - .4 ) * gap }); 37 38 39 40 var gray = Math . floor ( Math . random () * 16 ). toString ( 16 ); context . fillStyle = '#' + gray + gray + gray ; context . fill ();"
    },
    "https://generativeartistry.com/tutorials/cubic-disarray/": {
        "text": [
            "Georg Nees’ fantastic generative art is a true inspiration. In this tutorial, we’re going to build one of his pieces: Cubic Disarray.",
            "The only HTML we have on the page is a <canvas> element at 320×320 pixels.",
            "As usual, here is our initial setup. You’re not going to see anything render here, because these are the primary lines to setting up the canvas and context which we use to draw. We will also set the size of the canvas and adjust it based on the user’s device pixel ratio, or pixel density. This ensures that the final result is crisp on all monitors.",
            "We’ve also got a variable in there to define the square size, understandably named squareSize.",
            "Now, let’s create a function to draw the squares. This function is going to be fairly simple, taking only a width and a height. The position of the squares is going to be handled by another loop.",
            "So how about we draw something. I’m going to loop through and fill the screen  with squares. Here we’re using the context save, translate & restore functions to move the context around, and then our draw function above for drawing.",
            "And there we have it, squares! Now we have the “cubic” part down, we can get to the disarray.",
            "Introducing random is fairly simple: first we’ll give ourselves some variables, one for how much the squares translate out of their position, one for how much they rotate, and one for how much to offset the entire drawing to get it centered on the canvas.",
            "We can use those variables, then, to create the random translations and rotations. They’re set up here to be larger numbers as they reach towards the end of the canvas.",
            "Now, we apply the translations and rotations. (Suddenly all that setup paid off!)",
            "And there we have it: cubic disarray!"
        ],
        "code": " 1  2  3  4  5  6  7  8  9 10 11 12 var canvas = document . querySelector ( 'canvas' ); var context = canvas . getContext ( '2d' ); var size = window . innerWidth ; var dpr = window . devicePixelRatio ; canvas . width = size * dpr ; canvas . height = size * dpr ; context . scale ( dpr , dpr ); context . lineWidth = 2 ; var squareSize = 30 ; 13 14 15 16 17 18 function draw ( width , height ) { context . beginPath (); context . rect ( - width /2, -height/2, width, height); context . stroke (); } 19 20 21 22 23 24 25 26 27 for ( var i = squareSize ; i <= size - squareSize ; i += squareSize ) { for ( var j = squareSize ; j <= size - squareSize ; j += squareSize ) { context . save (); context . translate ( i , j ); draw ( squareSize , squareSize ); context . restore (); } } 11 12 13 14 var randomDisplacement = 15 ; var rotateMultiplier = 20 ; var offset = 10 ; 24 25 26 27 28 29 30 var plusOrMinus = Math . random () < 0.5 ? - 1 : 1 ; var rotateAmt = j / size * Math.PI / 180 * plusOrMinus * Math . random () * rotateMultiplier ; plusOrMinus = Math . random () < 0.5 ? - 1 : 1 ; var translateAmt = j / size * plusOrMinus * Math.random() * randomDisplacement; 31 32 33 context . translate ( i + translateAmt + offset , j + offset ); context . rotate ( rotateAmt );"
    },
    "https://generativeartistry.com/tutorials/joy-division/": {
        "text": [
            "The Joy Division album cover has a cool history, and is a beautiful example of data driven art. In this tutorial we’re going to recreate it in a more simplistic form.",
            "We’re going to do this with the JavaScript canvas. No extra APIs. The only HTML we have on the page is a <canvas> element at 320×320 pixels.",
            "Let’s kick things off with some initial setup. You’re not going to see anything render here, because these are the primary lines to setting up the canvas and context which we use to draw. We will also set the size of the canvas and adjust it based on the user’s device pixel ratio, or pixel density. This ensures that the final result is crisp on all monitors.",
            "This gives us access to the context which allows us to draw on the page.",
            "Our initial plan of attack here is to create the lines on the canvas, which will be a series of points. From there, we will start to displace the points randomly to give us the effect we desire.",
            "Let’s get some base variables in here: step, which will be the steps in pixels between our points, and an array called lines, which is going to hold our lines.",
            "Now we’ll write a function to prepare our lines. A line will consist of a series of points with x and y properties.",
            "Our next step will be to draw these lines. Again, we’ll start simple to get something on the page, and we will expand on it later.",
            "Amazing, we have lines on our canvas! Now, the next job we have is to displace them. We will do that up in our first loop, where we create the points.",
            "Ahh, there we have it. Our lines are now jumping all over the place, just as planned. The next step is to get them to distort in the areas that we want—namely, more distorted towards the center, and less towards the edges. We are going to do this with an absolute function.",
            "We can see here that we’ve made something a little messy and that we can see through each line, which doesn’t look great. We’re going to use a fill with a globalCompositeOperation of destination-out to fix this.",
            "Global composite operations allow us to draw to the canvas in very interesting ways. For our case, we want to essentially “erase” our new shape from the existing lines above it. The destination-out mode works great for erasing from a canvas. Check out this article to learn more about canvas global composite operations.",
            "We’re getting so close now. The only piece left is to make the lines much less jagged. To do this, we’re going to use quadratic curves, and create control points between each one to create a smooth path. The final quadraticCurveTo is the last joining step.",
            "This looks great! Now we just need a little breathing room on top. Let’s prevent the top lines from going off the top of the canvas. We can do this by starting the loop at a higher index to skip the drawing of a few of the top lines.",
            "And there we have it! You can mess with the steps, and styles and colors for a bunch of different results. All are exciting!"
        ],
        "code": " 1  2  3  4  5  6  7  8  9 10 var canvas = document . querySelector ( 'canvas' ); var context = canvas . getContext ( '2d' ); var size = window . innerWidth ; var dpr = window . devicePixelRatio ; canvas . width = size * dpr ; canvas . height = size * dpr ; context . scale ( dpr , dpr ); context . lineWidth = 2 ; 11 12 13 var step = 10 ; var lines = []; 14 15 16 17 18 19 20 21 22 23 24 // Create the lines  for ( var i = step ; i <= size - step ; i += step ) { var line = []; for ( var j = step ; j <= size - step ; j += step ) { var point = { x : j , y : i }; line . push ( point ); } lines . push ( line ); } 25 26 27 28 29 30 31 32 33 34 35 36 37 // Do the drawing  for ( var i = 0 ; i < lines . length ; i ++ ) { context . beginPath (); context . moveTo ( lines [ i ][ 0 ]. x , lines [ i ][ 0 ]. y ); for ( var j = 0 ; j < lines [ i ]. length ; j ++ ) { context . lineTo ( lines [ i ][ j ]. x , lines [ i ][ j ]. y ); } context . stroke (); } 19 20 21 var random = Math . random () * 10 ; var point = { x : j , y : i + random }; 19 20 21 22 var distanceToCenter = Math . abs ( j - size / 2); var variance = Math . max ( size / 2 - 50 - distanceToCenter, 0); var random = Math . random () * variance / 2 * -1; 38 39 40 41 42 context . save (); context . globalCompositeOperation = 'destination-out' ; context . fill (); context . restore (); 34 35 36 37 38 39 40 41 for ( var j = 0 ; j < lines [ i ]. length - 2 ; j ++ ) { var xc = ( lines [ i ][ j ]. x + lines [ i ][ j + 1 ]. x ) / 2; var yc = ( lines [ i ][ j ]. y + lines [ i ][ j + 1 ]. y ) / 2; context . quadraticCurveTo ( lines [ i ][ j ]. x , lines [ i ][ j ]. y , xc , yc ); } context . quadraticCurveTo ( lines [ i ][ j ]. x , lines [ i ][ j ]. y , lines [ i ][ j + 1 ]. x , lines [ i ][ j + 1 ]. y ); 29 30 for ( var i = 5 ; i < lines . length ; i ++ ) {"
    },
    "https://generativeartistry.com/tutorials/tiled-lines/": {
        "text": [
            "I want to get going with some of the earliest but simplest programming art out there. I’m referring to the 10 PRINT artwork initially coded for the Commodore 64. This work has been featured all over the place, and gives a really stunning effect for something so simple.",
            "We’re going to do this with the JavaScript canvas. No extra APIs today. The only HTML we have on the page is a <canvas> element at 320×320 pixels.",
            "Let’s kick things off with some initial setup. You’re not going to see anything render here, because these are the primary lines to setting up the canvas and context which we use to draw. We will also set the size of the canvas and adjust it based on the user’s device pixel ratio, or pixel density. This ensures that the final result is crisp on all monitors.",
            "This will set us up with a canvas with a square size ~ and provide us with the ever useful “context” of which we use to draw.",
            "Now, let’s create a draw function, which we will be using to draw. It’s going to accept an x, y, width and height. Let’s also call that draw function, even though it’s empty.",
            "The way that this is built out at the moment, we will use the draw function to draw out something from the x and y coordinates of (0, 0), to the full width and height of the canvas.",
            "So how about we draw something. Let’s start with a simple line.",
            "And there we have it: a diagonal line, going from our top left to the bottom right of the canvas space. But at the moment, that’s static.",
            "To make it “generative” we’ll need to change it so that 50% of the time, it will go from the top right to the bottom left instead, taking the “art” out of our hands and into the computers.",
            "To use that, we will add a random chance boolean and an if statement.",
            "Math.random() is returning a number between 0 and 1, which gives us the 50% chance of going one way or the other. Now, if you hit the “send it” button on the left over and over, you will see the line changing direction randomly.",
            "Now, the final step is to divide and conquer. One line is cool, but do you know what’s better? Hundreds of lines.",
            "We will add in a variable to be our “step”.",
            "This variable is what we will use to step through our image. In this case, our width is 320, and our step is 80, so we know it fits in 4 times.",
            "Kapow, how about that. So now, we can reduce the step to say:",
            "And we have a much more complex, beautiful piece. In fact, I’d almost call that done!",
            "Feel free to play around with the variables in the code to the top left… really, step is the one you should be most interested in. But you can also play around with draw and create something new by drawing something a little more complex than just diagonal lines."
        ],
        "code": " 1  2  3  4  5  6  7  8  9 10 11 12 var canvas = document . querySelector ( 'canvas' ); var context = canvas . getContext ( '2d' ); var size = window . innerWidth ; var dpr = window . devicePixelRatio ; canvas . width = size * dpr ; canvas . height = size * dpr ; context . scale ( dpr , dpr ); context . lineCap = 'square' ; context . lineWidth = 2 ; 13 14 15 16 17 18 function draw ( x , y , width , height ) { // TODO: Functionality here  } draw ( 0 , 0 , size , size ); 14 15 16 17 context . moveTo ( x , y ); context . lineTo ( x + width , y + height ); context . stroke (); 14 15 16 17 18 19 20 21 22 23 24 25 var leftToRight = Math . random () >= 0.5 ; if ( leftToRight ) { context . moveTo ( x , y ); context . lineTo ( x + width , y + height ); } else { context . moveTo ( x + width , y ); context . lineTo ( x , y + height ); } context . stroke (); 5 6 var step = 80 ; 28 29 30 31 32 33 for ( var x = 0 ; x < size ; x += step ) { for ( var y = 0 ; y < size ; y += step ) { draw ( x , y , step , step ); } } 5 6 var step = 20 ;"
    }
}